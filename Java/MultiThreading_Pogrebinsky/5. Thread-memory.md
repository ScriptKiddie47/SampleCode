# Stack Memory

1. Memory where 
    - methods are executed
    - Argument passing
    - Local Variable Storage
1. Stack + Instruction pointer = State of each thread's execution
1. All variables belong to the thread executing on that stack
1. Stack size is fixed and relatively small


# Heap

1. All objects ( `new` operator)
    - String
    - Object
    - Collection

1. Members of classes
1. Static variables - 
1. Managed by GC
1. Objects stay as long as we have a reference
1. Static Variables - Stay Forever
1. References =! Objects

### Note 

1. References can be allocated on the stack
1. Can be allocated on the heap if they are members of a class

# Share Resource between threads

1. What is a resource
    - Variables ( Integers,Strings.. )
    - Data Strcuture
    - Files
    - Any objects

1. What is the problem of sharing resouces ?
1. Lets look at one code example. The premise is quite simple. We are in a wherehouse where we have multiple items which we count using a simple count attribute , increment & decrement function to adjust the no# of items.We also have 2 thread classes using which we increment and decrement as per our requirement.

```java
package org.example;

public class Main {
    public static class DecrementingThead extends Thread{
        private InventoryCountry inventoryCountry;
        public DecrementingThead(InventoryCountry inventoryCountry){
            this.inventoryCountry = inventoryCountry;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                inventoryCountry.decrement();
            }
        }
    }

    public static class IncrementingThead extends Thread{
        private InventoryCountry inventoryCountry;
        public IncrementingThead(InventoryCountry inventoryCountry){
            this.inventoryCountry = inventoryCountry;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                inventoryCountry.increment();
            }
        }
    }

    private static class InventoryCountry{
        private int items = 0;
        public void increment(){
            items++;
        }
        public void decrement() {
            items--;
        }
        public int getItems(){
            return items;
        }
    }

      public static void main(String[] args) throws InterruptedException {
        InventoryCountry inventoryCountry = new InventoryCountry();
        IncrementingThead incrementingThead = new IncrementingThead(inventoryCountry);
        DecrementingThead decrementingThead = new DecrementingThead(inventoryCountry);

        // Code added here will be mentioned below

        System.out.println("We currently have : " + inventoryCountry.getItems() + " items");

    }

}
```

1. So the 2 threads perform a single job.
1. Increment 10,000 items and decrement 10,000 items. We we run them syncronously 

    ```java
    incrementingThead.start();
    incrementingThead.join();

    decrementingThead.start()
    decrementingThead.join();
    ```

1. We get the output - `We currently have : 0 items` everytime which is expected
1. However if we run them in parallel

    ```java
    incrementingThead.start();
    decrementingThead.start();

    incrementingThead.join();
    decrementingThead.join();
    ```

1. We get varying results for every run.

    ```
    We currently have : -1157 items
    We currently have : -461 items
    We currently have : 48 items
    .
    ...
    ```

1. This is because inventoryCountry is a shared object.
    - items member is shared between 2 threads
    - Operations items++ & items-- are happening at the same time.
    - Operations items++ & items-- are not atomic operations


### Atomic Operation 

1. An operation or a set of operations is considered atomic, if it appears to the rest of the system s if it occurred at once.
1. Single step - "all or nothing'
1. No intermediate states
1. items++ is not an atomic operation. It can be divided into 3 ops
    - Get current value of items
    - Increment current value by 1
    - Store result in items variable

# Critical Scction
    - Function / method where concurrent access can cause harm to the code

## Synchronized 

1. Locking mechanism
1. Restrict access to critical section or entire method to a single thread at a time
1. 2 ways to use it
1. 1st way - Monitor
    - declare 1 or more method in a class as syncronized so when 1 or more threads call onto these methods only 1 thread will be able to execute only either of those methods in a class
    - For example if Thread A is excuted sync method 1 & but not sync method 2.
    - Thread B won't be able to touch both sync method 1 & 2.
    - This is because sync is applied per object 
    - The correct term would be monitor

    ```java
        private static class InventoryCountry{
        private int items = 0;
        public synchronized void increment(){
            items++;
        }
        public synchronized void decrement() {
            items--;
        }
        public synchronized int getItems(){
            return items;
        }
    }
    ```
    - this gives the correct output everytime we run it.

    ```
    We currently have : 0 items
    ```

1. 2nd Way - Lock
    - Define a sync block & define a object to sync on to restrict access only to it.
    - Any sync block which is sync on the same object will allow only 1 thread to executing inside our block
    - This lock offers us better oppurtunity in some cases
    - Only a small portion of the method would need to be sync , others can run cocurrent code

    ```java
        private static class InventoryCountry {
        private int items = 0;
        Object lock = new Object();

        public void increment() {
            synchronized (this.lock) {
                items++;
            }
        }

        public void decrement() {
            synchronized (this.lock) {
                items--;
            }
        }

        public int getItems() {
            synchronized (this.lock) {
                return items;
            }
        }
    ```

    - Sync block is Reentrant
    - A thread cannot prevent itself from entering a critical section

## Atomic Operations

1. All reference assignments are atomic.
1. We can get and set references to objects atomically.
1. All assignments to primitive types are safe expect `long` and `double`
    - That means reading and writing to the following types
    - int,short,byte,float,char,boolean

1. Long and Double are exception because they are 64 bit
    - Write will take 2 operatios

1. Thankfully java provides us with a solution 
    - `long` & `double` if declared volatile

1. Classes in the java.util.concurrent.atomic 
    - Provides more advanced operations

1. Lets look at a use case:

